<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Synced Metronome</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      --emerald-bg: #10b981;
      --emerald-text: #ffffff;
      --default-bg: #ffffff;
      --default-text: #111;
      --button-bg: #007AFF;
      --button-hover: #0051c3;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
      text-align: center;
      padding: 2rem;
      margin: 0;
      background-color: var(--default-bg);
      color: var(--default-text);
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    body.playing {
      background-color: var(--emerald-bg);
      color: var(--default-text);
    }

    h1 {
      margin-bottom: 1rem;
      font-size: 2rem;
      font-weight: 600;
    }

    #controls {
      background: rgba(255, 255, 255, 0.8);
      border-radius: 1rem;
      padding: 1.5rem;
      margin: 1rem auto;
      max-width: 600px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.1);
      backdrop-filter: blur(10px);
    }

    #hostControls {
      display: grid;
      gap: 1rem;
      margin-top: 2rem;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
      background: rgba(255,255,255,0.85);
      padding: 1.5rem;
      border-radius: 1rem;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    #bpmDisplay {
      font-size: 3rem;
      font-weight: 700;
      color: #000;
    }

    .bpm-adjust {
      display: none;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    .bpm-adjust button {
      font-size: 1.5rem;
      padding: 0.5rem 1rem;
      width: 3rem;
    }

    #bpmValue {
      font-size: 1.5rem;
      width: 4rem;
      text-align: center;
    }

    .beat-indicators {
      display: flex;
      justify-content: center;
      gap: 1.5rem;
      margin: 2rem auto 1rem;
    }

    .dot {
      width: 4rem;
      height: 4rem;
      border-radius: 50%;
      background: #ccc;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .dot.active {
      background: var(--button-bg);
      transform: scale(1.2);
    }

    button {
      padding: 0.8rem 1.5rem;
      font-size: 1rem;
      margin: 0.3rem;
      border: none;
      border-radius: 1rem;
      background: var(--button-bg);
      color: white;
      cursor: pointer;
      box-shadow: 0 4px 10px rgba(0, 122, 255, 0.2);
      transition: background 0.3s ease, transform 0.2s ease;
    }

    button:hover {
      background: var(--button-hover);
      transform: translateY(-1px);
    }

    label {
      display: block;
      margin-top: 0.5rem;
      font-weight: 500;
    }

    select, input[type="range"] {
      width: 100%;
      padding: 0.6rem;
      margin-bottom: 0.5rem;
      border-radius: 0.5rem;
      border: 1px solid #ccc;
      background: #f9f9f9;
    }

    @media (max-width: 600px) {
      h1 { font-size: 1.5rem; }
      button { width: 100%; margin: 0.5rem 0; }
      .beat-indicators { gap: 1rem; }
      .dot { width: 3rem; height: 3rem; }
    }
  </style>
</head>
<body>
  <h1>Synced Metronome</h1>
  <div class="beat-indicators" id="beatDots"></div>

  <div id="controls">
    <p id="roleChooser">
      Your Role: <strong id="roleLabel">Not Set</strong><br>
      <button onclick="setRole('host')">Host</button>
      <button onclick="setRole('client')">Client</button>
    </p>
    <div class="bpm-adjust" id="bpmAdjust">
      <div>
        <button onclick="changeBpm(-1)">-</button>
        <input id="bpmValue" readonly value="120">
        <button onclick="changeBpm(1)">+</button>
      </div>
      <input type="range" id="bpmSlider" min="30" max="300" value="120" style="width: 100%; margin-top: 1rem;">
    </div>
    <p id="bpmDisplay">120</p>
    <p id="tsWrapper">Time Signature: <span id="tsDisplay">--</span></p>
    <p id="subdivWrapper">Subdivision: <span id="subdivDisplay">--</span></p>
    <p id="statusDisplay"></p>
  </div>

  <div id="hostControls" style="display:none;">
    <label for="timeSigInput">Time Signature:</label>
    <select id="timeSigInput">
      <option value="4/4">4/4</option>
      <option value="3/4">3/4</option>
      <option value="6/8">6/8</option>
    </select>

    <label for="subdivisionInput">Subdivision:</label>
    <select id="subdivisionInput">
      <option value="1">Quarter Note (1/4)</option>
      <option value="2">Eighth Note (1/8)</option>
      <option value="4">Sixteenth Note (1/16)</option>
    </select>

    <label for="latencyAdjust">Latency Compensation (ms):</label>
    <input type="range" id="latencyAdjust" min="-500" max="500" value="0">

    <div style="display:flex; gap:1rem; justify-content:center; flex-wrap:wrap; margin-top: 1rem;">
      <button onclick="updateSettings()">Set Settings</button>
      <button onclick="startMetronome()">Start</button>
      <button onclick="stopMetronome()">Stop</button>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    let bpm = 120, isRunning = false, startTime = null, nextTick = 0;
    let role = null, timeOffset = 0, tickTimer = null;
    let subdivision = 1, timeSignature = '4/4';
    let beatCount = 0;
    let manualLatencyMs = 0;

    const latencyAdjustInput = document.getElementById('latencyAdjust');
    const bpmAdjust = document.getElementById('bpmAdjust');
    const bpmSlider = document.getElementById('bpmSlider');
    const tsWrapper = document.getElementById('tsWrapper');
    const subdivWrapper = document.getElementById('subdivWrapper');
    const roleChooser = document.getElementById('roleChooser');

    function updateBeatDots() {
      const container = document.getElementById('beatDots');
      container.innerHTML = '';
      const beats = parseInt(timeSignature.split('/')[0]);
      for (let i = 0; i < beats; i++) {
        const dot = document.createElement('div');
        dot.classList.add('dot');
        container.appendChild(dot);
      }
    }

    function highlightDot(index) {
      const dots = document.querySelectorAll('.dot');
      dots.forEach((dot, i) => {
        dot.classList.toggle('active', i === index);
      });
    }

    function changeBpm(delta) {
      bpm = Math.max(20, Math.min(300, bpm + delta));
      bpmSlider.value = bpm;
      document.getElementById('bpmValue').value = bpm;
      document.getElementById("bpmDisplay").textContent = `BPM: ${bpm}`;
      if (role === 'host') updateSettings();
    }

    bpmSlider.addEventListener('input', () => {
      bpm = parseInt(bpmSlider.value);
      document.getElementById('bpmValue').value = bpm;
      document.getElementById("bpmDisplay").textContent = `BPM: ${bpm}`;
      if (role === 'host') updateSettings();
    });

    latencyAdjustInput.addEventListener('input', (e) => {
      manualLatencyMs = parseInt(e.target.value);
    });

    async function syncTime() {
      const samples = [];
      for (let i = 0; i < 5; i++) {
        const t0 = performance.now();
        const res = await fetch('/time');
        const t1 = performance.now();
        const json = await res.json();
        const rtt = t1 - t0;
        const serverTime = json.serverTime + rtt / 2;
        const offset = serverTime - Date.now();
        samples.push(offset);
        await new Promise(r => setTimeout(r, 50));
      }
      samples.sort((a, b) => a - b);
      timeOffset = samples[Math.floor(samples.length / 2)];
    }

    function globalNow() {
      return Date.now() + timeOffset;
    }

    function scheduleClick(time, isDownbeat = false) {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      gain.gain.setValueAtTime(1, time);
      gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
      osc.frequency.setValueAtTime(isDownbeat ? 1500 : 1000, time);
      osc.start(time);
      osc.stop(time + 0.05);
    }

    function tickLoop() {
      if (!isRunning) return;
      const interval = (60 / bpm) / subdivision;
      const now = audioCtx.currentTime;
      const beatsPerBar = parseInt(timeSignature.split('/')[0]);
      const ticksPerBar = beatsPerBar * subdivision;

      while (nextTick < now + 0.2) {
        const isDownbeat = (beatCount % ticksPerBar === 0);
        scheduleClick(nextTick, isDownbeat);
        if (beatCount % subdivision === 0) {
          const visualBeat = Math.floor((beatCount / subdivision) % beatsPerBar);
          highlightDot(visualBeat);
        }
        nextTick += interval;
        beatCount++;
      }
      tickTimer = requestAnimationFrame(tickLoop);
    }

    function syncClock(data) {
      bpm = data.bpm;
      document.getElementById('bpmValue').value = bpm;
      bpmSlider.value = bpm;
      isRunning = data.isRunning;
      startTime = data.startTime;
      subdivision = data.subdivision || 1;
      timeSignature = data.timeSignature || '4/4';
      beatCount = 0;
      updateBeatDots();
      document.getElementById("tsDisplay").textContent = timeSignature;
      document.getElementById("subdivDisplay").textContent = subdivision;
      document.getElementById("bpmDisplay").textContent = `BPM: ${bpm}`;
      document.body.classList.toggle('playing', isRunning);

      if (tickTimer) {
        cancelAnimationFrame(tickTimer);
        tickTimer = null;
      }
    
      if (!isRunning) {
        const dots = document.querySelectorAll('.dot');
        dots.forEach(dot => dot.classList.remove('active'));
        return;
      }
    
      if (isRunning && startTime) {
        audioCtx.resume().then(() => {
          const delayMs = (startTime - globalNow()) + manualLatencyMs;
          const clampedDelay = Math.max(0, delayMs); // never schedule in past
          setTimeout(() => {
            nextTick = audioCtx.currentTime;
            tickLoop();
          }, clampedDelay);
        }).catch(err => {
          console.warn("AudioContext failed to resume:", err);
        });
      }
    }


    socket.on('sync', syncClock);

    socket.on('clientCount', (count) => {
      const status = (role === 'host')
        ? `Clients connected: ${count - 1}`
        : `You + ${count - 1} others`;
      document.getElementById("statusDisplay").textContent = status;
    });

    function updateSettings() {
      const ts = document.getElementById("timeSigInput").value;
      const subdiv = parseInt(document.getElementById("subdivisionInput").value);
      socket.emit('updateSettings', {
        bpm,
        timeSignature: ts,
        subdivision: subdiv
      });
    }

    function startMetronome() {
      audioCtx.resume();
      socket.emit('startMetronome');
    }

    function stopMetronome() {
      isRunning = false;
      socket.emit('stopMetronome');
    }

    function setRole(r) {
      role = r;
      document.getElementById("roleLabel").textContent = r;
      roleChooser.style.display = 'none';
      const isHost = r === 'host';
      document.getElementById("hostControls").style.display = isHost ? 'block' : 'none';
      latencyAdjustInput.style.display = isHost ? 'block' : 'none';
      bpmAdjust.style.display = isHost ? 'flex' : 'none';
      tsWrapper.style.display = isHost ? 'block' : 'none';
      subdivWrapper.style.display = isHost ? 'block' : 'none';
      syncTime().then(() => {
        socket.emit('identify', r);
      });
    }
  </script>
</body>
</html>