<!DOCTYPE html>
<html lang="en">

<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Synced Metronome</title>
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <h1>Synced Metronome</h1>
  <div class="version-display" id="versionDisplay">v...</div>
  <div class="version-meta">
    <p>Last Modified: 2025-12-23</p>
    <p>Developer: Hye Sung Moon</p>
  </div>
  <div class="beat-indicators" id="beatDots"></div>

  <div class="card">
    <div id="roleChooser">
      <h2>Choose Your Role</h2>
      <p>Host: Control the metronome</p>
      <p>Client: Follow host's metronome</p>
      <div class="button-group">
        <button id="btnChooseHost" onclick="setRole('host')">Host</button>
        <button id="btnChooseClient" onclick="setRole('client')">Client</button>
      </div>
      <p id="hostTakenMsg" style="display:none; color:#d32f2f; margin-top:0.5rem; font-size:0.9rem;">Host role is currently occupied.</p>
    </div>

    <div id="metronomeControls" style="display:none;">
      <p id="bpmDisplay">120</p>
      <div id="clientVisuals" class="visual-indicators">
        <div class="visual-indicator">
          <div class="time-sig-visual" id="timeSignatureVisual">
            <div class="numerator">4</div>
            <div class="divider"></div>
            <div class="denominator">4</div>
          </div>
        </div>
        <div class="visual-indicator">
          <div class="subdiv-visual" id="subdivisionVisual">
            <!-- Will be filled dynamically -->
          </div>
        </div>
      </div>
      <div id="statusInfo">
        <p id="statusDisplay"></p>
        <p id="latencyDisplay"></p>
      </div>
    </div>

    <div id="hostControls" style="display:none;">
      <div class="settings-grid">
        <div class="form-group">
          <div class="bpm-controls" id="bpmControls" style="display: flex;">
            <div class="bpm-buttons">
              <button onclick="changeBpm(-1)">-</button>
              <input id="bpmValue" value="120">
              <button onclick="changeBpm(1)">+</button>
            </div>
            <input type="range" id="bpmSlider" min="30" max="300" value="120">
            <div class="button-group" style="margin-top: 1rem;">
              <button id="startButton" onclick="startMetronome()">Start</button>
              <button id="stopButton" class="stop" onclick="stopMetronome()" disabled>Stop</button>
            </div>
          </div>
        </div>
        <div class="form-group">
          <label for="timeSigInput">Time Signature:</label>
          <select id="timeSigInput">
            <option value="4/4">4/4</option>
            <option value="3/4">3/4</option>
            <option value="6/8">6/8</option>
          </select>
        </div>
        <div class="form-group">
          <div style="display: flex; align-items: center; justify-content: space-between;">
            <label for="subdivisionInput" style="margin:0;">Subdivision:</label>
            <div id="hostSubdivisionVisual" style="height: 38px;"></div>
          </div>
          <select id="subdivisionInput" style="margin-top: 0.5rem;">
            <option value="1">Quarter Note (1/4)</option>
            <option value="2" selected>Eighth Note (1/8)</option>
            <option value="3">Eighth Note Triplets</option>
            <option value="4">Sixteenth Note (1/16)</option>
          </select>
        </div>
      </div>
      <div id="presetBank">
        <h3>Preset Bank</h3>
        <button onclick="handleSavePreset()">Save Current Preset</button>
        <ul id="presetList"></ul>
      </div>
    </div>
  </div>
</body>

<script src="/socket.io/socket.io.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/nosleep/0.12.0/NoSleep.min.js"></script>

<script>
  const socket = io();
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // Metronome state
  let bpm = 120;
  let isRunning = false;
  let startTime = null;
  let nextTick = 0;
  let role = null;
  let timeOffset = 0;
  let tickTimer = null;
  let subdivision = 2;
  let timeSignature = '4/4';
  let beatCount = 0;
  let syncTimeout = null;

  // DOM Elements
  const metronomeControls = document.getElementById('metronomeControls');
  const roleChooser = document.getElementById('roleChooser');
  const bpmControls = document.getElementById('bpmControls');
  const bpmSlider = document.getElementById('bpmSlider');
  const bpmInput = document.getElementById('bpmValue');
  const startButton = document.getElementById('startButton');
  const stopButton = document.getElementById('stopButton');
  const clientVisuals = document.getElementById('clientVisuals');
  const noSleep = new NoSleep();
  const btnChooseHost = document.getElementById('btnChooseHost');
  const hostTakenMsg = document.getElementById('hostTakenMsg');

  // Fetch and display version from server
  fetch('/version')
    .then(res => res.json())
    .then(data => {
      document.getElementById('versionDisplay').textContent = `v${data.version}`;
    })
    .catch(err => console.error('Failed to fetch version:', err));

  // Slider fill logic
  function updateSliderFill(slider) {
    const min = +slider.min || 0;
    const max = +slider.max || 100;
    const val = +slider.value;
    const percent = ((val - min) / (max - min)) * 100;
    slider.style.setProperty('--val', percent + '%');
  }
  // Init and update slider fill on input/change

  if (bpmSlider) {
    updateSliderFill(bpmSlider);
    bpmSlider.addEventListener('input', () => updateSliderFill(bpmSlider));
    bpmSlider.addEventListener('change', () => updateSliderFill(bpmSlider));
  }

  // Enable audio context on user interaction
  document.body.addEventListener('click', () => {
    if (audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
  });
  // Enable audio context on user interaction
  document.body.addEventListener('click', () => {
    if (audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
  });

  // Update BPM value display when slider changes
  bpmSlider.addEventListener('input', () => {
    bpm = parseInt(bpmSlider.value);
    bpmInput.value = bpm;
    document.getElementById("bpmDisplay").textContent = `${bpm}`;
    updateSliderFill(bpmSlider);
    if (role === 'host') {
      debounceUpdateSettings();
      renderPresets();
    }
  });

  // Handle direct BPM input changes
  bpmInput.addEventListener('change', () => {
    let newBpm = parseInt(bpmInput.value);
    // Clamp BPM to valid range
    newBpm = Math.max(30, Math.min(300, newBpm || 120));
    bpm = newBpm;
    bpmInput.value = bpm;
    bpmSlider.value = bpm;
    updateSliderFill(bpmSlider);
    document.getElementById("bpmDisplay").textContent = `${bpm}`;
    if (role === 'host') {
      updateSettings();
    }
  });

  let wakeLock = null;
  let silentSource = null;

  async function requestWakeLock() {
    try {
      if ('wakeLock' in navigator) {
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLock.addEventListener('release', () => {
          console.log('Wake Lock released');
        });
        console.log('Wake Lock active');
      }
    } catch (err) {
      console.error(`${err.name}, ${err.message}`);
    }
  }

  function startSilentAudio() {
    if (silentSource) return;
    try {
      const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate, audioCtx.sampleRate);
      silentSource = audioCtx.createBufferSource();
      silentSource.buffer = buffer;
      silentSource.loop = true;
      silentSource.connect(audioCtx.destination);
      silentSource.start();
      console.log('Silent audio started for active state');
    } catch (e) {
      console.error("Error starting silent audio:", e);
    }
  }

  function enableWakeLockAndAudio() {
    console.log("enableWakeLockAndAudio called. AudioContext state:", audioCtx.state, "NoSleep enabled:", noSleep.isEnabled);
    if (audioCtx.state === 'suspended') {
      audioCtx.resume().then(() => {
        console.log("AudioContext resumed.");
        startSilentAudio();
      }).catch(e => console.error("AudioContext resume error:", e));
    } else {
      startSilentAudio();
    }
    
    requestWakeLock();

    // This is the key part for NoSleep:
    if (!noSleep.isEnabled) {
      noSleep.enable().then(() => {
        console.log("Screen wake lock is active."); // You should see this in your console
      }).catch(e => console.error("Failed to enable screen wake lock:", e));
    }
    document.body.removeEventListener('click', enableWakeLockAndAudio);
    document.body.removeEventListener('touchstart', enableWakeLockAndAudio);
  }
document.body.addEventListener('click', enableWakeLockAndAudio);
document.body.addEventListener('touchstart', enableWakeLockAndAudio);

  // Update time signature visual display
  function updateTimeSignatureVisual(ts) {
    const [numerator, denominator] = ts.split('/').map(Number);
    const visual = document.getElementById('timeSignatureVisual');
    const numeratorEl = visual.querySelector('.numerator');
    const denominatorEl = visual.querySelector('.denominator');
    numeratorEl.textContent = numerator;
    denominatorEl.textContent = denominator;
  }

  // Update subdivision visual display
  function updateSubdivisionVisual(subdiv) {
    subdiv = parseInt(subdiv);
    
    // Update both client and host visuals
    const targets = [
      document.getElementById('subdivisionVisual'),
      document.getElementById('hostSubdivisionVisual')
    ];

    targets.forEach(container => {
      if (!container) return;
      container.innerHTML = '';
      
      const img = document.createElement('img');
      img.className = 'note-icon';
      
      switch (subdiv) {
        case 1:
          img.src = 'icons/quarter.svg';
          img.alt = 'Quarter Note';
          break;
        case 2:
          img.src = 'icons/eighth.svg';
          img.alt = 'Eighth Notes';
          break;
        case 3:
          img.src = 'icons/triplet.svg';
          img.alt = 'Triplets';
          break;
        case 4:
          img.src = 'icons/sixteenth.svg';
          img.alt = 'Sixteenth Notes';
          break;
        default:
          console.warn('Unknown subdivision:', subdiv);
          return;
      }
      container.appendChild(img);
    });
  }

  // Create visual beat indicators based on time signature
  function updateBeatDots() {
    const container = document.getElementById('beatDots');
    container.innerHTML = '';
    const [numerator, denominator] = timeSignature.split('/').map(Number);
    for (let i = 0; i < numerator; i++) {
      const dot = document.createElement('div');
      dot.classList.add('dot');
      if (i === 0) {
        dot.classList.add('accent');
      }
      container.appendChild(dot);
    }
  }

  // Highlight the current beat dot
  function highlightDot(index) {
    const dots = document.querySelectorAll('.dot');
    dots.forEach((dot, i) => {
      dot.classList.toggle('active', i === index);
    });
  }

  // Flash the screen
  function flashScreen(isAccent) {
    const flashClass = isAccent ? 'flash-accent' : 'flash';
    document.body.classList.add(flashClass);
    setTimeout(() => {
      document.body.classList.remove(flashClass);
    }, 50);
  }

  // Change BPM value
  function changeBpm(delta) {
    bpm = Math.max(30, Math.min(300, bpm + delta));
    bpmSlider.value = bpm;
    bpmInput.value = bpm;
    updateSliderFill(bpmSlider);
    document.getElementById("bpmDisplay").textContent = `${bpm}`;
    if (role === 'host') {
      updateSettings();
    }
  }

  // Debounce function for slider changes
  let updateTimeout = null;
  function debounceUpdateSettings() {
    clearTimeout(updateTimeout);
    updateTimeout = setTimeout(updateSettings, 300);
  }

  // Synchronize time with server
  async function syncTime() {
    const samples = [];
    document.getElementById('latencyDisplay').textContent = 'Syncing with server...';
    
    try {
      // Take more samples for better accuracy
      for (let i = 0; i < 16; i++) {
        const t0 = performance.now();
        const res = await fetch('/time');
        const t1 = performance.now();
        const json = await res.json();
        const roundTrip = t1 - t0;
        
        // Calculate offset assuming symmetric latency
        const serverTime = json.serverTime + (roundTrip / 2);
        const offset = serverTime - Date.now();
        
        samples.push({ roundTrip, offset });
        
        // Random jitter to avoid lock-step issues
        await new Promise(r => setTimeout(r, 50 + Math.random() * 50));
      }

      // Sort by round trip time to find best samples (lowest latency)
      samples.sort((a, b) => a.roundTrip - b.roundTrip);
      
      // Use the best 50% of samples (lowest RTT) to filter out network spikes
      const bestSamples = samples.slice(0, Math.floor(samples.length / 2));
      
      // Calculate average offset from best samples
      // We can also use median, but average of best samples is robust enough
      const sumOffset = bestSamples.reduce((acc, s) => acc + s.offset, 0);
      timeOffset = Math.round(sumOffset / bestSamples.length);
      
      // Calculate average latency from best samples for display
      const avgLatency = Math.round(bestSamples.reduce((acc, s) => acc + s.roundTrip, 0) / bestSamples.length);
      
      document.getElementById('latencyDisplay').textContent = `Avg Latency: ~${avgLatency}ms`;
      console.log('Sync complete. Time offset:', timeOffset, 'Avg Latency:', avgLatency, 'Best samples:', bestSamples);
      return true;
    } catch (error) {
      console.error('Failed to sync time:', error);
      document.getElementById('latencyDisplay').textContent = 'Time sync failed. Please refresh.';
      return false;
    }
  }

  function globalNow() {
    return Date.now() + timeOffset;
  }

  function scheduleClick(time, isAccent = false) {
    const noiseLength = isAccent ? 0.08 : 0.05;
    const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * noiseLength, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
      data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (isAccent ? 140 : 200));
    }
    const noise = audioCtx.createBufferSource();
    noise.buffer = buffer;
    const gain = audioCtx.createGain();
    gain.gain.setValueAtTime(isAccent ? 2.0 : 1.0, time);
    gain.gain.linearRampToValueAtTime(0.001, time + noiseLength);
    noise.connect(gain).connect(audioCtx.destination);
    noise.start(time);
    const osc = audioCtx.createOscillator();
    const oscGain = audioCtx.createGain();
    osc.type = isAccent ? 'square' : 'triangle';
    osc.frequency.setValueAtTime(isAccent ? 1500 : 1000, time);
    oscGain.gain.setValueAtTime(isAccent ? 10.0 : 5.0, time);
    oscGain.gain.linearRampToValueAtTime(0.001, time + (isAccent ? 0.09 : 0.05));
    osc.connect(oscGain).connect(audioCtx.destination);
    osc.start(time);
    osc.stop(time + (isAccent ? 0.09 : 0.05));
  }

  function tickLoop() {
    if (!isRunning) return;
    try {
      const interval = (60 / bpm) / subdivision;
      const now = audioCtx.currentTime;
      const [numerator, denominator] = timeSignature.split('/').map(Number);
      const ticksPerBar = numerator * subdivision;
      while (nextTick < now + 0.2) {
        const currentBeat = Math.floor(beatCount / subdivision);
        const isFirstBeat = (beatCount % ticksPerBar === 0);
        const isMainBeat = (beatCount % subdivision === 0);
        scheduleClick(nextTick, isFirstBeat);
        if (isMainBeat) {
          const visualBeat = currentBeat % numerator;
          requestAnimationFrame(() => {
            highlightDot(visualBeat);
            flashScreen(isFirstBeat);
          });
        }
        nextTick += interval;
        beatCount++;
      }
      tickTimer = requestAnimationFrame(tickLoop);
    } catch (error) {
      console.error('Error in tick loop:', error);
      if (isRunning) {
        setTimeout(() => {
          if (isRunning) {
            tickTimer = requestAnimationFrame(tickLoop);
          }
        }, 1000);
      }
    }
  }

  function syncClock(data) {
    bpm = data.bpm;
    subdivision = data.subdivision || 1;
    timeSignature = data.timeSignature || '4/4';
    bpmInput.value = bpm;
    bpmSlider.value = bpm;
    updateSliderFill(bpmSlider);
    document.getElementById("bpmDisplay").textContent = `${bpm}`;
    updateTimeSignatureVisual(timeSignature);
    updateSubdivisionVisual(subdivision);
    updateBeatDots();
    const wasRunning = isRunning;
    isRunning = data.isRunning;
    document.body.classList.toggle('playing', isRunning);
    if (role === 'host') {
      startButton.disabled = isRunning;
      stopButton.disabled = !isRunning;
    }
    if (!isRunning && wasRunning) {
      if (tickTimer) {
        cancelAnimationFrame(tickTimer);
        tickTimer = null;
      }
      if (syncTimeout) {
        clearTimeout(syncTimeout);
        syncTimeout = null;
      }
      document.querySelectorAll('.dot').forEach(dot => dot.classList.remove('active'));
      return;
    }
    if (isRunning && data.startTime) {
      if (wasRunning && tickTimer) {
        cancelAnimationFrame(tickTimer);
        tickTimer = null;
      }
      startTime = data.startTime;
      startMetronomeSync();
    }
  }

  function startMetronomeSync() {
    if (syncTimeout) {
      clearTimeout(syncTimeout);
      syncTimeout = null;
    }
    try {
      audioCtx.resume().then(() => {
        const now = globalNow();
        const intervalMs = (60000 / bpm) / subdivision;
        const elapsedMs = now - startTime;
        const ticksSinceStart = Math.floor(elapsedMs / intervalMs);
        const nextTickTimeMs = startTime + (ticksSinceStart + 1) * intervalMs;
        const delayMs = nextTickTimeMs - now;
        
        // Calculate the precise AudioContext time for the next tick
        // We map the target Server Time to AudioContext time
        // Relation: AudioTime = CurrentAudioTime + (TargetServerTime - CurrentServerTime)
        // Note: dividing by 1000 because audioCtx uses seconds
        const delaySec = delayMs / 1000;
        
        // Compensate for Output Latency if available (experimental feature)
        // audioCtx.outputLatency is the time from processing to sound output
        // We subtract it to schedule the sound earlier so it *arrives* on time
        const hardwareLatency = (audioCtx.outputLatency || 0) + (audioCtx.baseLatency || 0);
        
        // Set nextTick anchor based on the math, not "now"
        nextTick = audioCtx.currentTime + delaySec - hardwareLatency;
        
        const clampedDelay = Math.max(0, Math.min(1000, delayMs));
        
        syncTimeout = setTimeout(() => {
          syncTimeout = null;
          // Don't reset nextTick here! It's already set precisely above.
          // Just update the beat count
          beatCount = ticksSinceStart + 1;
          tickLoop();
        }, clampedDelay);
      }).catch(err => {
        console.error('Audio context resume error:', err);
      });
    } catch (error) {
      console.error('Error starting metronome:', error);
    }
  }

  socket.on('sync', syncClock);

  socket.on('clientCount', (count) => {
    const connectedCount = count - 1;
    document.getElementById("statusDisplay").textContent = connectedCount === 1
      ? `1 client connected`
      : `${connectedCount} clients connected`;
  });

  socket.on('hostAvailability', (isAvailable) => {
    if (role) return; // Only update if still in role selection screen
    
    if (isAvailable) {
      btnChooseHost.disabled = false;
      btnChooseHost.textContent = "Host";
      btnChooseHost.title = "";
      hostTakenMsg.style.display = 'none';
    } else {
      btnChooseHost.disabled = true;
      btnChooseHost.textContent = "Host (Occupied)";
      btnChooseHost.title = "Another user is already the host";
      hostTakenMsg.style.display = 'block';
    }
  });

  function updateSettings() {
    if (role !== 'host') return;
    const ts = document.getElementById("timeSigInput").value;
    const subdiv = parseInt(document.getElementById("subdivisionInput").value);
    updateTimeSignatureVisual(ts);
    updateSubdivisionVisual(subdiv);
    updateBeatDots();
    
    const payload = {
      bpm,
      timeSignature: ts,
      subdivision: subdiv
    };

    if (isRunning) {
      const delayMs = (nextTick - audioCtx.currentTime) * 1000;
      const nextBeatTime = globalNow() + delayMs;
      const newInterval = (60000 / bpm) / subdiv;
      payload.startTime = nextBeatTime - (beatCount * newInterval);
    }

    socket.emit('updateSettings', payload);
  }

  document.getElementById("timeSigInput").addEventListener('change', function () {
    updateTimeSignatureVisual(this.value);
    updateSettings();
  });

  document.getElementById("subdivisionInput").addEventListener('change', function () {
    updateSubdivisionVisual(parseInt(this.value));
    updateSettings();
  });

  function startMetronome() {
    if (role !== 'host') return;
    audioCtx.resume();
    startSilentAudio();
    requestWakeLock();
    startButton.disabled = true;
    if (!noSleep.isEnabled) { 
      noSleep.enable().catch(err => console.error('Failed to enable NoSleep on metronome start:', err));
    }
    socket.emit('startMetronome');
  }

  function stopMetronome() {
    if (role !== 'host') return;
    isRunning = false;
    stopButton.disabled = true;
    if (tickTimer) {
      cancelAnimationFrame(tickTimer);
      tickTimer = null;
    }
    // clear highlight immediately
    document.querySelectorAll('.dot').forEach(dot => dot.classList.remove('active'));
    socket.emit('stopMetronome');
  }

  function setRole(r) {
    role = r;
    roleChooser.style.display = 'none';
    metronomeControls.style.display = 'block';
    const isHost = r === 'host';
    document.getElementById("hostControls").style.display = isHost ? 'block' : 'none';
    clientVisuals.style.display = isHost ? 'none' : 'flex';
    document.getElementById("bpmDisplay").style.display = isHost ? 'none' : 'block';
    document.getElementById("statusInfo").style.display = isHost ? 'none' : 'block';
    updateBeatDots();
    updateTimeSignatureVisual(timeSignature);
    updateSubdivisionVisual(subdivision);
    syncTime().then((success) => {
      if (success) {
        socket.emit('identify', r);
      }
    });
  }

  function getPresets() {
    return JSON.parse(localStorage.getItem('metronomePresets') || '[]');
  }

  function savePreset(preset) {
    const presets = getPresets();
    presets.push(preset);
    localStorage.setItem('metronomePresets', JSON.stringify(presets));
  }

  function deletePreset(index) {
    const presets = getPresets();
    presets.splice(index, 1);
    localStorage.setItem('metronomePresets', JSON.stringify(presets));
  }

  function handleSavePreset() {
    const ts = document.getElementById("timeSigInput").value;
    const subdiv = parseInt(document.getElementById("subdivisionInput").value);
    const name = `${bpm} BPM, ${ts}, Sub: ${subdiv}`;
    const preset = {
      name,
      bpm,
      timeSignature: ts,
      subdivision: subdiv,
    };
    savePreset(preset);
    renderPresets();
  }

  function handleLoadPreset(idx) {
    const preset = getPresets()[idx];
    if (preset) {
      bpm = preset.bpm;
      document.getElementById("bpmSlider").value = bpm;
      document.getElementById("bpmValue").value = bpm;
      updateSliderFill(bpmSlider);
      document.getElementById("bpmDisplay").textContent = `${bpm}`;
      document.getElementById("timeSigInput").value = preset.timeSignature;
      document.getElementById("subdivisionInput").value = preset.subdivision;
      updateTimeSignatureVisual(preset.timeSignature);
      updateSubdivisionVisual(preset.subdivision);
      updateSettings();
    }
  }

  function handleDeletePreset(idx) {
    deletePreset(idx);
    renderPresets();
  }

  function renderPresets() {
    const list = document.getElementById('presetList');
    list.innerHTML = '';
    const presets = getPresets();
    presets.forEach((preset, i) => {
      const li = document.createElement('li');
      li.innerHTML = `
      <span style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">
        ${preset.bpm} BPM ${preset.timeSignature}, ${subdivisionToText(preset.subdivision)}
      </span>
      <button class="preset-btn" onclick="handleLoadPreset(${i})">load</button>
      <button class="preset-btn" onclick="handleDeletePreset(${i})">delete</button>
    `;
      list.appendChild(li);
    });
  }

  function subdivisionToText(subdivision) {
    switch (subdivision) {
      case 1: return 'quarter';
      case 2: return 'eighth';
      case 3: return 'triplet';
      case 4: return 'sixteenth';
      default: return 'custom';
    }
  }
</script>

</html>